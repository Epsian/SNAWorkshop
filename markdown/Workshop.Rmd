---
title: "Social Network Analysis Workshop"
author: "Jared Joseph"
date: "August 31, 2017"
output: 
  html_document:
    code_folding: hide
    df_print: paged
runtime: shiny
---

```{r setup, include=FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE)
if(!require(statnet)){
    install.packages("statnet")
    library(statnet)
}
par.d = par()
```

### Thinking with Networks

Early? Make sure that you have installed the statnet package, or play around with this while you wait!

https://oracleofbacon.org/

What do these connections mean? How are they related to networks?

# What Can You Expect from this Workshop?

This workshop is intended to give an introduction to Social Network Analysis (SNA) in R, using the Statnet package. We will cover the core concepts in SNA, when you might consider using it, what data kind of data is required, and how to go about exploring your own data. *igraph* is another popular network package in R, and while we won't cover it here, the network prinicples are transferable.

The workshop assumes you have a working knowlage of R.

# What is Social Network Analysis (SNA)?

SNA is a method to look at relational data, meaning that rather than looking only at attributes of specific data points, we are looking at the connections between data. IN SNA, data points are called **nodes**, and the connections between them are called **edges**. These components create a **network**, defined by [Wasserman & Faust (1994)](http://www.cambridge.org/us/academic/subjects/sociology/sociology-general-interest/social-network-analysis-methods-and-applications?format=PB) as "finite set or sets of actors and the relation or relations defined on them."
```{r First Network}
set.seed(10)
e.m = rgraph(2, mode="graph", tprob = .4)
e.n = network(e.m, matrix.type = "adjacency", directed = FALSE)
par(mar=c(0,0,0,0))
plot(e.n, label = "Node", edge.label = "edge", vertex.cex = 3)
```

By looking at these connections in aggregate, we can generate a network that represents the structure of those connections. By taking an outside perspective, we may be able to see patterns of resource flow, centralization of power, or other structural patterns that may not be apparent from the perspective of an individual point in the network.

## Examples
### Social Sciences
As far back as 1932, networks have been of interest in the social sciences. Jacob Moreno is credited with one of the first network based studies, focusing on runaway school children, and how their associations could predict running more than any attributes of the individual children. Since then, networks have been used in the social sciences to study community cohesion, gender attitudes in the family, and crime.

Borgatti, S. P., Mehra, A., Brass, D. J., & Labianca, G. (2009). Network Analysis in the Social Sciences. Science, 323(5916), 892.

### Neuroscience
The brain is often conceptualised as a network of neurons, which inspired the neural network family of machine leraning algorthms. SNA is sometimes used to make path models of the brain, charting how different barin reigons interact.

### Chemestry
Network models are sometimes used as analogs for atoms and molocules, with different types of edgest representing different bonds. 

### The Internet
The internet is based on a network structure of sites and hyperlinks, making SNA useful for visualization and understanding the influence of certain sites. One netowork measure, "PageRank" was developed by Google to measure the relative importance of certain webpages, and optimize their search engine.

### Infastructure
SNA is often used to look at infastructure such as the electrical grid, with power stations as nodes and power lines as edges. Using some network measures, it is possible to see which stations are overburdened with relaying power, and which ones act as bottlenecks. You can also see which ones would cut power to the most people if they were to fail.

### Security
Closely tied to the above example is the use of SNA in security. The US Government uses SNA like methods to map criminal and terorist orgonizations, and uses tools like 'Keyplayer' to identify the most vital individuals in a network, and which individuals whose removal will most damage the network.

See [Network Science by Albert-László Barabási](http://barabasi.com/networksciencebook) for elaborations on these examples and more.

## Graph Level Properties
Social networks can be either **directed** or **undirected**. A directed network tracks what node is sending something to another node, while undirected networks consider all edges to be mutual. Which one you may find useful largely depends on what you are interested in, and the data you are using. Consider connections on Facebook as mutual, as all friends are mutual, meanwhile on Twitter, users follow one another, but that connection does not have to be mutual. This is represented visually using arrows.
```{r Directionality}
set.seed(31)
e.m = rgraph(10, mode="digraph", tprob = .17)
e.d = network(e.m, matrix.type = "adjacency", directed = TRUE)
e.u = network(e.m, matrix.type = "adjacency", directed = FALSE)

par(mfrow=c(1,2))
plot(e.d, main = "Directed", arrowhead.cex = 3, vertex.cex = 3)
plot(e.u, main = "Undirected", vertex.cex = 3)
```

**Density** is a measure of how many edges exist in a network out of the total possible edge count, using $\frac{Actual Edges}{Possible Edges}$. Networks that are more densely connected are considered to be more cohesive, and robust, in that the removal of any specific edge will not have a great effect of the network as a whole. It also means that, given the nodes being individuals, each node will have a more direct route to resources that may be present in the network, as they know more individuals who may have the resource they are looking for, or will have a greater chance of knowing someone else who does.
```{r Density}
set.seed(10)
de.h = network(rgraph(10, mode="digraph", tprob = .7), matrix.type = "adjacency", directed = FALSE)
de.l = network(rgraph(10, mode="digraph", tprob = .1), matrix.type = "adjacency", directed = FALSE)

par(mfrow=c(1,2))
plot(de.h, main = "High Density", vertex.cex = 3)
plot(de.l, main = "Low Density", vertex.cex = 3)
```

**Centralization** measures give a sense of the shape of the network. Conssider the three networks below. The first "Star" network would be considered highly centralised, as one node connects all the others. It would receve a degree centralization score of 1, as 100% of the ties are connected with one node. The line network would have a score of 0.1, as every node is equally connected to each other, ???????????????????????????????????
```{r Centralization}
ce.star = matrix(data = c(0,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0), nrow = 6, ncol = 6)
ce.star = network(ce.star, matrix.type = "adjacency", directed = FALSE)

ce.line = matrix(data = c(0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0), nrow = 6, ncol = 6)
ce.line = network(ce.line, matrix.type = "adjacency", directed = FALSE)

ce.circle = matrix(data = c(0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0), nrow = 6, ncol = 6)
ce.circle = network(ce.circle, matrix.type = "adjacency", directed = FALSE)

par(mfrow=c(1,3))
plot(ce.star, main = "Star", vertex.cex = 3)
plot(ce.line, main = "Line", vertex.cex = 3)
plot(ce.circle, main = "Circle", vertex.cex = 3)
```



**Degree Centralization**

**Betweenness Centralization**

## Node Level Properties
**Degree** measures are counts of how many edges are connected to a node. You can count incoming, outgoing, or total (Freeman) degree counts. This gives a very rough measure of how popular or central a node is in the network. 

**Geodesic Distance** is defined as "the length of the shortest path via the edges or binary connections between nodes." [(Kadushin 2012)](https://global.oup.com/academic/product/understanding-social-networks-9780195379471?q=Understanding%20Social%20Networks&lang=en&cc=us)
```{r Geodesic, echo=FALSE, message=FALSE, warning=FALSE}
data(florentine)
gd = geodist(flomarriage)$gdist
colnames(gd) = flomarriage%v%"vertex.names"
row.names(gd) = flomarriage%v%"vertex.names"
par(par.d)
plot(flomarriage, main = "Florentine Marriage Network", displaylabels = TRUE, label.pos = 0, arrowhead.cex = 3, vertex.cex = 3)
knitr::kable(gd)
```


**K-Core** measures the the minimum degree of nodes in an area of the network. This results in redementary clustering of nodes.
```{r, warning=FALSE}
par(par.d)
kc = kcores(flomarriage, mode="graph",diag=FALSE)
plot(flomarriage, main = "K-Cores", vertex.cex = 3, vertex.col = kc+1)
```

**Centrality** measures how prominent or popular a specific node is in a network. 

**Eigenvector Centrality**

**Betweenness Centrality**

## Try it Yourself!
Here is an interactive network graph. Try adjusting the parameters to see how it affects the network!
```{r Interactive Plot}
require(shiny)
wellPanel(
numericInput("Nodes", "How many nodes?", 10),
sliderInput("TieProb", "Tie Probability?", min = 0, max = 1, .5),
checkboxInput("Dir.check", "Directed?")
)

renderPlot({
  plot(network(rgraph(input$Nodes, mode = "digraph", tprob = input$TieProb), matrix.type = "adjacency", directed = input$Dir.check), arrowhead.cex = 3, vertex.cex = 3)
})
```

### Example Data
```{r Florentine}
set.seed(12)
data(florentine)
plot(flomarriage, main = "Florentine Marriage Network", displaylabels = TRUE, label.pos = 0, arrowhead.cex = 3, vertex.cex = 3)
```

# What does SNA Data Look Like?
Data for SNA is ultimately just relational data; if you have a list of Xs interacting with Ys, you have network data. However, there are two main ways to represent that data to be useful in SNA using R.

## Adjacency Matrix
An **adjacency matrix** is a matrix with each node in your network represented as a row and column. If two nodes are connected, a one is put into the matrix where they intersect, if they do not, the value is zero. The sender nodes are the rows, and the receiver nodes are the columns. It is possible to weight connections (i.e. have a 2 or 3 represent multiple connections, but it is not well supported.)

```{r}
am = as.sociomatrix(e.d)
colnames(am) = letters[1:length(colnames(am))]
row.names(am) = letters[1:length(row.names(am))]
knitr::kable(am)
```

## Edgelist
An **edgelist** is a long matrix with two columns containing the unique names for your nodes. The first column is called **ego**, which contains who is sending the connection in a directed network. The second column is called **alter**, or who is receiving the connection. In an undirected network, you only need to include a connection in one direction, and it will always count as mutual. The columns do not need to be named ego and alter, but those are the common terms used in network research. 

```{r}
el = as.data.frame(as.edgelist(e.d), stringsAsFactors = FALSE)
key = data.frame(id = 1:10, name = letters[1:10])
colnames(el) = c("ego", "alter")
el$ego = key[match(el[["ego"]], key[["id"]]), "name"]
el$alter = key[match(el[["alter"]], key[["id"]]), "name"]
knitr::kable(el)
```

Both of these data sets create the following network. Try comparing the data sets to the plot, looking at directionality specifically.
```{r}
e.d%v%"vertex.names" = letters[1:length(e.d%v%"vertex.names")]
plot(e.d, displaylabels = TRUE, label.pos = 0, arrowhead.cex = 3, vertex.cex = 3)
```

## Isolates and Largest Components
Regardless of how your data is formatted, it is likely that not all nodes will be connected to each other. Depending on how the data was collected, you may even have **isolates** in your data, or nodes that have no edges at all; these appear as lone dots in network graphs. There can also be multiple **components** or collection of nodes that are tied to each other. Even though they are not connected, these components are considered to be the same 'network' if they came from the same data.

Many of the analyses discussed above cannot be run on a network with multiple components. For example, if we tried to get the geodesic distances of the nodes in this network, it would return only NAs, as some nodes cannot reach other nodes in the network, so their distance is unobtainable. The quickest way to deal with this situation is to reduce the network to only the largest component. In most networks, this will remove only a small amount of data, but it could be the case that you have a network that is split more evenly; always look at your network before making such decisions. 

Presented is a comparison between a total network, and he largest component:
```{r components}
set.seed(26)
com = rgraph(30, mode="graph", tprob = .08)
com = network(com, directed = FALSE)

capture.output({
lcom = com
lcom%v%"lc" = component.largest(lcom)
lcom = delete.vertices(lcom, which(lcom%v%"lc" == FALSE))
}, file = tempfile()) #These are just to silence some code output, remove them if you would like!

par(mfrow = c(1,2))
plot(com, main = "Multiple Components and Isolates", arrowhead.cex = 3, vertex.cex = 3)
plot(lcom, main = "Largest Component Only", arrowhead.cex = 3, vertex.cex = 3)
```

# What Can SNA Do?
## Good For
Looking at relational data.
## Bad For
Multiplex Networks (in Statnet) - Statnet has the ability to handle multiplex networks, but it is difficult and unintuitive.

### Bibliography


*Special Thanks to Dr. Chris Smith, ... . This presentation was created with the help of [(Kadushin 2012)](https://www.amazon.com/Understanding-Social-Networks-Theories-Concepts/dp/0195379470/ref=pd_bxgy_14_img_3?_encoding=UTF8&psc=1&refRID=9MSKEK7804SY2RS02HQG).*

http://faculty.ucr.edu/~hanneman/nettext/C10_Centrality.html